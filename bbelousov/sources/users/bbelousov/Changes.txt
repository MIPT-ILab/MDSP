memory.h
    1. Изменен копирующий конструктор для объектов класса Byte.
        Было:
            Byte( const Byte& byte):byte_val( byte.getByteVal()), output( DEFAULT_OUT), flag( DEFAULT_FLAG){}
        Стало:
            Byte( const Byte& byte):byte_val( byte.getByteVal()), output( DEFAULT_OUT), flag( byte.getFlagEnable()){}
        Сделано для того, чтобы при копировании байта копировался флаг.
    
    2. Изменено описание для метода ByteLine класса MemVal
            ByteLine getByteLine( unsigned int index, unsigned int len) const;
        Изменен был лишь порядок аргументов, т.к. фактически они используются в таком порядке. Раньше все работало, потому что оба аргумента одного типа.

memory.cpp
    1. Копирующий конструктор
        ByteLine::ByteLine( const ByteLine& line)
        был модифицирован с тем, чтобы при копировании байта копировать флаг его состояния. Добавлена строка
        ( *byte_line).at( i).setFlagEnable( line.getByte( i).getFlagEnable());

    2. Изменена функция void MemVal::writeByteLine( const ByteLine& line, unsigned int index)
        Раньше при копировании байта не выставлялся флаг состояния, хотя по задумке автора это должно было происходить.

    3. Изменена функция void MemVal::writeByteLine( const ByteLine & line)
        Встает философский вопрос: Зачем нужны флажки, приписанные байтам? У меня 2 варианта:
        1) Символизировать тот факт, что в байт была произведена запись;
        2) Символизировать тот факт, что байт вообще используется.
        Я придерживался 1 варианта, изменяя эту функцию. Здесь флаг состояния не выставляется, а копируется тот флаг, который был у байта источника.
!!!     В связи с этим возникает проблема: Эта функция используется для инициализации, поэтому если тут выставлять флаги всегда, то в памяти у всех
        байтов будут выставлены флаги и нет проблем с остановом процессора (он попадет на строку нулей и остановится). В ином случае (как есть сейчас)
        последнюю команду (halt) надо явно записывать в перечень команд.
        Если мы придерживаемся второго варианта - проблем нет. Функцию надо сделать симметричной предыдущей.

    4. Если я верно понимаю назначение аттрибута flag у объекта класса Byte (т.е. этот флаг говорит о том, что мы писали в этот байт),
       то становится неясно, зачем нужны были закомментированные нынче строки в функциях ByteLine MemVal::getByteLine( unsigned int index, unsigned int count) const и
       ByteLine MemVal::getByteLine() const; В них проверяется флаг, хотя эти функции могут использоваться просто для копирования ByteLine'ов (кстати и используются),
       при этом флаги не обязаны стоять. В общем эти проверки избыточны. В функции readBL напротив проверка необходима, т.к. читать то, чего нет нам ни к чему.
       См. ниже изменения в файле register_file.cpp (схожая ситуация).

register_file.cpp
    1. В фуекции ByteLine RegVal::getByteLine() const закомментирована проверка флага, т.к. этот флаг не обязан стоять.
    
config.cpp
    1. Изменен деструктор Config::~Config(), т.к. он не работал.
       Было:
        delete[] this->input_filename;
        delete[] this->log_filename;
       Стало
        delete this->input_filename;
        delete this->log_filename.

test.cpp
    1. Я ничего не менял. А стоило бы. Полно ошибок, которые появляются, если в main'е раскомментировать testMemVal().
       Суть ошибок в том, что сравниваемая строка и экземпляр для сравнения отличаются кол-вом пробелов или табуляций. Нужно разобраться и расставить их в правильном порядке.

P.S. Для тех кто хочет все-таки посмотреть, как процессор работает от начала и до конца:
        Заменить memory.cpp на memory(modified).cpp, собраться и запустить. Поздравляю!