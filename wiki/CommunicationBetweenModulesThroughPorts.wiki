#summary Communication between modules using ports
#labels Phase-Design,Cheatsheet

= Introduction =
 
== Motivation ==

Current trends in semiconductor scaling indicate that wire delay will play a critical role in processor performance. Thus, time and, more specifically, delays between and in hardware structures must become first-class abstractions in the processor design representation. For this reason, and to keep the interfaces between modules cleaner and better defined, we created MDSP's ports communication paradigm.

Ports define interfaces between modules to facilitate coding of reusable modules. A well-defined interface disallows implicit side effects, which might hinder the fidelity, reusability, and portability of model code. Traditionally, performance models use
method calls and global variables to pass information between hardware structures. Unfortunately, these techniques permit an unrestricted information flow that allows unexpected side effects to occur.

== Functions == 

Ports have the two main functions in MDSP:

 * To pass information from one module to another.

 * To model delays within a hardware structure.

==== Between modules ====
Modules that represent hardware structures exchange information through ports. A real processor or system typically does not have any global information instantaneously accessible anywhere in the chip.Instead, a processor’s state is distributed among several hardware components that might take several cycles to communicate. Components that need to access the state of other components must do so through explicit communication. Ports represent communication channels that let modules representing hardware components communicate such state information with one another.

To pass information from one module to another, the sending module must write the relevant information to the port. The receiving module on the other side of the port’s connection reads the information from the port.

==== Within a module ====
MDSP also uses ports to model delays within a hardware structure. <wiki:comment> Insert an example here </wiki:comment> It creates a clear separation between a hardware algorithm, independent of time, and the timing component itself.

== Port paradigms ==

==== Bandwidth and latency ====
Like real hardware, ports have a fixed latency and a maximum bandwidth. The information that a module sends through a port does not appear in the receiving module before the port’s fixed latency elapses. Similarly, a module cannot send more information than the port’s bandwidth allows. Thus, MDSP can accurately model wire delays and bandwidth between modules.

==== Port connection ====
MDSP implements ports through first-in, first-out (FIFO) queues. Each module declares one end of the port. The sending module declares an output port with an identifier string, and the receiving module declares the corresponding input port with the same identifier string. MDSP’s utility code handles the actual connection between output and input ports.
The utility code runs at initialization and connects output and input ports using the identifier strings.

==== Clocking ====
In fact, there is no clock method for ports. Instead, the number of the current cycle is necessary when writing or reading from the ports. If the write clock and the port's latency are know it is easy to calculate the read clock, i.e. the moment when data can be read from the port.
----------------------------------------------------------------------------------------

= Using details =

The Port class is implemented as a templated C++ class. This means that a Port can be used to communicate any type of data. This part contains detailed information about how to use MDSP ports.

== Port Basics ==

=== Setup ===

The following steps should be done to setup the port (all other connection details happen automatically):

<ol>  
<li> Declare the endpoints. </li> 
   _Note that a port consists of two parts: write (or input) and read (or output). Be careful, usually they are also called "ports", but only their combination is a real port._
<li> Initialize them with the same unique string. </li>

<li> Set bandwidth and latency. </li>
   Only the input knows the real bandwidth and only the output knows the latency. It means that the sending module defines the bandwidth and the receiving module defines the latency (i.e. different received modules can provide different latencies without changing of the sending module).
</ol>

Let's look at an example:
<ol>
<li> Declare the write port, and give it a type (`CpuInstr` is used for all our examples, but any type or class will work): </li>

{{{  
   WritePort<CpuInstr> var1_wport( Key, Bandwidth, Fanout);
}}}
  
The string is used to connect the ports. Bandwidth is the desired bandwidth for this connection. Fanout is number of connected read parts of ports.

<li> Declare the read port with the same type as the write port it will get connected to: </li>

{{{
    ReadPort<CpuInstr> var2_rport( Key, Latency); 
}}} 
  
Again, the string is used to connect the ports.  The other parameter, latency is the desired latency for this connection.
</ol>
  
Note that the SAME unique string is used for each port. This is how the ports are connected, so these MUST be the same exact string for each connection. 

After declaring all the ports, you should init them with command
{{{
    Port<CpuInstr>::portMap->init(); 
}}}

=== Using Ports ===
Using ports is pretty simple. Carrying on with the previous example:
<ul>
<li> To write instr1 to a port: </li>

{{{  
   CpuInstr instr1;
   ... // fulfill instr1
   var1_wport.write( instr1, cycle); // Where cycle is a current CPU cycle number.
}}}

<li> To read data from a port: </li>

{{{
   CpuInstr instr2; 

   var2_rport.read( instr2, cycle); // Where instr2 is пшмут as a reference parameter,
                                    // i.e. the read function fulfills it.
                                    // Cycle is a current CPU cycle number.
}}}
</ul>

=== Error checking ===

==== Dublicating of keys ====

You can create two writing ports with the same key, but younger one will replace older one in map of ports. You'll got message with warning:

{{{
    Reusing of '<name>' key for WritePort. Last WritePort will be used.
}}}

==== No initialization error ====

If you try to write or to read from uninitialized ports, you'll get message:

{{{
   <name> <type>Port was not initializated
}}}

and critical error.

==== Errors during initialization ====

When you call initialization of ports, you may get some messages:

{{{
    No WritePort for '<name>' key
}}}

It means that there's no writing port with this key, but there are reading ports with that. It's a critical error and execution will be stopped.

{{{
    No ReadPorts for '<name>' key
}}}

Similar, but about reading ports.

{{{
    <name> WritePort is overloaded by fanout
}}}

Your writing port is connected to greater number of reading ports, than mentioned in fanout. It's a critical error.

{{{
    <name> WritePort is underloaded by fanout
}}}

Your writing port is connected to lesser number of reading ports, than mentioned in fanout. It's NOT a critical error, it's just a warning because that situation can happen during some debug works.

==== Overloading by bandwidth ====

Overloading by bandwidth is a critical error, you'll be notified about it (on calling .write( ) method) with message:

{{{
    Port '<name>' is overloaded by bandwidth
}}}

==== Finding lost tokens ====

Command 

{{{
    Port<type>::portMap->lost( cycle) 
}}}
will show you is there any 'lost tokens' in ports, which were added and haven't been got yet.